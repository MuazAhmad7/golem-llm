---
description:
globs:
alwaysApply: false
---
# Algolia Search Provider Implementation Rules

## Project Structure

- **Required Directory Layout:**
  ```
  llm/search-algolia/
  ├── Cargo.toml
  ├── src/
  │   ├── lib.rs           # Component entry point
  │   ├── client.rs        # Algolia API client
  │   ├── conversions.rs   # Type conversions
  │   └── bindings.rs      # Generated WIT bindings
  └── wit/
      ├── algolia.wit      # Provider-specific WIT
      └── deps/            # WIT dependencies
  ```

## Code Organization

- **Module Responsibilities:**
  ```rust
  // lib.rs - Component entry point and interface implementation
  pub struct AlgoliaSearch {
      client: AlgoliaClient,
      config: Config,
  }
  
  // client.rs - Algolia API client implementation
  pub struct AlgoliaClient {
      app_id: String,
      api_key: String,
      http_client: Client,
  }
  
  // conversions.rs - Type conversion utilities
  impl From<AlgoliaSearchHit> for SearchHit {
      fn from(hit: AlgoliaSearchHit) -> Self {
          // Convert Algolia types to WIT types
      }
  }
  ```

## Error Handling

- **Error Mapping Pattern:**
  ```rust
  // ✅ DO: Map Algolia errors to WIT variants
  match algolia_error {
      AlgoliaError::NotFound => SearchError::IndexNotFound,
      AlgoliaError::InvalidQuery(msg) => SearchError::InvalidQuery(msg),
      AlgoliaError::RateLimit => SearchError::RateLimited,
      _ => SearchError::Internal(error.to_string()),
  }
  
  // ❌ DON'T: Expose raw Algolia errors
  return Err(algolia_error);
  ```

## Configuration Management

- **Environment Variables:**
  ```rust
  // ✅ DO: Use environment variables for configuration
  let config = Config {
      app_id: env::var("ALGOLIA_APP_ID")?,
      api_key: env::var("ALGOLIA_API_KEY")?,
      timeout: env::var("SEARCH_PROVIDER_TIMEOUT")
          .unwrap_or("30".to_string())
          .parse()?,
  };
  
  // ❌ DON'T: Hardcode configuration
  let config = Config {
      app_id: "your-app-id",
      api_key: "your-api-key",
      timeout: 30,
  };
  ```

## Type Conversions

- **WIT to Algolia:**
  ```rust
  // ✅ DO: Implement clear type conversions
  impl From<SearchQuery> for AlgoliaQuery {
      fn from(query: SearchQuery) -> Self {
          AlgoliaQuery {
              query: query.q,
              filters: query.filters.join(" AND "),
              page: query.page.unwrap_or(0),
              hits_per_page: query.per_page.unwrap_or(20),
              facets: query.facets,
          }
      }
  }
  
  // ❌ DON'T: Use unsafe type coercion
  let algolia_query = unsafe { std::mem::transmute(wit_query) };
  ```

## Feature Support

- **Graceful Degradation:**
  ```rust
  // ✅ DO: Handle unsupported features explicitly
  fn update_schema(&self, index: String, schema: Schema) -> Result<(), SearchError> {
      // Algolia doesn't support direct schema updates
      Err(SearchError::Unsupported)
  }
  
  // ❌ DON'T: Silently ignore unsupported features
  fn update_schema(&self, index: String, schema: Schema) -> Result<(), SearchError> {
      Ok(()) // This is misleading
  }
  ```

## HTTP Client Usage

- **Connection Management:**
  ```rust
  // ✅ DO: Implement proper connection pooling
  let client = reqwest::Client::builder()
      .pool_idle_timeout(Duration::from_secs(30))
      .pool_max_idle_per_host(10)
      .timeout(Duration::from_secs(timeout))
      .build()?;
  
  // ❌ DON'T: Create new clients per request
  let client = reqwest::Client::new();
  ```

## Testing

- **Test Categories:**
  ```rust
  // ✅ DO: Implement comprehensive tests
  #[cfg(test)]
  mod tests {
      #[test]
      fn test_query_conversion() {
          // Test WIT to Algolia query conversion
      }
      
      #[test]
      fn test_error_mapping() {
          // Test error variant mapping
      }
      
      #[tokio::test]
      async fn test_search_integration() {
          // Test against real Algolia instance
      }
  }
  ```

## Performance Optimization

- **Request Batching:**
  ```rust
  // ✅ DO: Batch operations when possible
  async fn upsert_many(&self, docs: Vec<Document>) -> Result<(), SearchError> {
      // Use Algolia's batch API
      self.client.batch_objects(docs, Some("id")).await?;
  }
  
  // ❌ DON'T: Make multiple single requests
  for doc in docs {
      self.upsert(doc).await?;
  }
  ```

## Documentation

- **Code Comments:**
  ```rust
  // ✅ DO: Document complex implementations
  /// Converts a WIT search query to Algolia's query parameters
  /// 
  /// # Arguments
  /// * `query` - The WIT search query to convert
  /// 
  /// # Returns
  /// An Algolia-compatible query object
  pub fn to_algolia_query(query: SearchQuery) -> AlgoliaQuery {
      // Implementation
  }
  
  // ❌ DON'T: Leave critical code undocumented
  pub fn to_algolia_query(query: SearchQuery) -> AlgoliaQuery {
      // Magic happens here
  }
  ```

## Durability Integration

- **Checkpoint Pattern:**
  ```rust
  // ✅ DO: Implement proper durability checkpoints
  async fn stream_search(&self, query: SearchQuery) -> Result<Stream<SearchHit>, SearchError> {
      let mut page = 0;
      stream::try_unfold(page, |current_page| async move {
          // Create durability checkpoint
          checkpoint!("page", current_page)?;
          
          let results = self.search_page(query.clone(), current_page).await?;
          if results.hits.is_empty() {
              return Ok(None);
          }
          Ok(Some((results.hits, current_page + 1)))
      })
  }
  ```

## Security

- **API Key Handling:**
  ```rust
  // ✅ DO: Use secure key management
  let api_key = env::var("ALGOLIA_API_KEY")
      .expect("ALGOLIA_API_KEY must be set");
  
  // ❌ DON'T: Log sensitive information
  println!("Using API key: {}", api_key);
  ```

## Monitoring & Logging

- **Structured Logging:**
  ```rust
  // ✅ DO: Use proper logging
  tracing::info!(
      index = %index_name,
      query = ?search_query,
      "Executing search request"
  );
  
  // ❌ DON'T: Use println or unstructured logging
  println!("Searching index {} with query {:?}", index_name, search_query);
  ```
